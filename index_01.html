<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>例子1</title>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script type="x-shader/x-vertex" id="vertexshader_01">
        varying vec3 vNormal; //out
        varying vec2 vUv;
        varying vec3 vPos; 
        varying vec3 fragPos;
        void main() { 
            vNormal = normal; //calculate normal direction 
            vUv = uv; 
            vPos = position;
            fragPos = vec3(modelMatrix * vec4(vPos, 1.0));
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vPos, 1.0);// 好像连顺序都不能乱
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_01">
        //似乎加载不了材质，代码？非2次幂？
        //
        varying vec3 vNormal; //原始法向量
        varying vec2 vUv; //UV，指导着色器绘制贴图,range(0,1)(0,1)
        varying vec3 vPos; //
        varying vec3 fragPos;//片段位置，可理解为像素
        uniform vec3 lightColor;//光源颜色
        uniform vec3 lightPos;//光源位置
        uniform vec3 viewPos;//摄像机、观察者位置
        uniform vec3 objectColor;//物体颜色,有材质时不需要 
        void main() { 
            float ambi = 0.1;//系数，同下方diff、spec
            vec3 ambient = ambi * lightColor;
            
            vec3 norm = normalize(vNormal);//标准化法向量
            vec3 lightDir = normalize(lightPos - fragPos);//标准化光源向量
            float diff = max(dot(norm,lightDir),0.0);//点乘，使用max函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数
            vec3 diffuse = diff * lightColor;//lightColor

            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);//reflect函数？
            float spec = pow(max(dot(viewDir,reflectDir),0.0),32);//pow(***,Shininess),反光度，此处为32,range(0,256)
            vec3 specular = 0.5 * spec * lightColor;

            vec3 result = (ambient + diffuse + specular) * objectColor;
            gl_FragColor = vec4(result,1.0);
        }

    </script>
    <script type="x-shader/x-vertex" id="vertexshader_02">
        varying vec3 vNormal; //out
        varying vec2 vUv;
        varying vec3 vPos; 
        varying vec3 fragPos;
        void main() { 
            vNormal = normal; //calculate normal direction 
            vUv = uv; 
            vPos = position;
            fragPos = vec3(modelMatrix * vec4(vPos, 1.0));
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vPos, 1.0);// 好像连顺序都不能乱
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_02">
        //似乎加载不了材质，代码？非2次幂？
        //
        struct Material{
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            float shininess;
        }
        uniform Material material_01;
        varying vec3 vNormal; //原始法向量
        varying vec2 vUv; //UV，指导着色器绘制贴图,range(0,1)(0,1)
        varying vec3 vPos; //
        varying vec3 fragPos;//片段位置，可理解为像素
        uniform vec3 lightColor;//光源颜色
        uniform vec3 lightPos;//光源位置
        uniform vec3 viewPos;//摄像机、观察者位置
        uniform vec3 objectColor;//物体颜色,有材质时不需要 
        void main() { 
            vec3 ambient = material_01.ambient * lightColor;
            
            vec3 norm = normalize(vNormal);//标准化法向量
            vec3 lightDir = normalize(lightPos - fragPos);//标准化光源向量
            float diff = max(dot(norm,lightDir),0.0);//点乘，使用max函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数
            vec3 diffuse = lightColor * (diff * material.diffuse);

            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);//reflect函数？
            float spec = pow(max(dot(viewDir,reflectDir),0.0),material.shininess);//pow(***,Shininess),反光度，此处为32,range(0,256)
            vec3 specular = lightColor * (spec * material.specular);

            vec3 result = ambient + diffuse + specular;
            gl_FragColor = vec4(result,1.0);
        }

    </script>

    <style type="text/css">
        div#canvas-frame {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 600px;
            background-color: #eeeeee;
        }
        
        .contain {
            display: flex;
            justify-content: space-around;
            margin-top: 40px;
            overflow: auto;
        }
        
        .instruct {
            background-color: #dffaf0ce;
            padding: 0 20px;
            width: 300px;
            text-align: center;
            line-height: 40px;
        }
        
        body {
            margin: 0;
            background-color: #a8f0ecce;
        }
    </style>
</head>

<body>
    <div class="contain">
        <div class="instruct">
            <h2>操作说明</h2>
            <span>切换桌面shader:<br>数字键1:默认材质<br>数字键2:绿色材质<br>数字键3:硬木材质<br>数字键4:石砖材质<br>数字键5:画布材质</span>
        </div>
        <div id="wrap"></div>
    </div>
</body>
<script>
    var container
    var camera, scene, renderer
        //用于轨道控制器
    var orbitControls
    var planeMesh
    var texture_01
    var pureUniform = {
        color: {
            value: new THREE.Color(0x66CCFF)
        },
        texture: {
            value: texture_01
        }
    };
    var MatUniform = {

    };
    uniforms1.texture.value.wrapS = uniforms1.texture.value.wrapT = THREE.RepeatWrapping;
    var pureMaterial_01 = new THREE.ShaderMaterial({
        uniforms: pureUniform,
        vertexShader: document.getElementById('vertexshader_01').textContent,
        fragmentShader: document.getElementById('fragmentshader_01').textContent
    });
    var pureMaterial_02 = new THREE.ShaderMaterial({
        uniforms: MatUniform,
        vertexShader: document.getElementById('vertexshader_01').textContent,
        fragmentShader: document.getElementById('fragmentshader_01').textContent
    });
    
    main()
    render()
    window.onkeydown = function(e) {
            if (e && e.keyCode === 49) {
                planeMesh.material = pureMaterial_01;
            }
            if (e && e.keyCode === 50) {
                planeMesh.material = pureMaterial_02;
            }
            planeMesh.material.side = THREE.DoubleSide
            planeMesh.material.needsUpdate = true;
            planeMesh.needsUpdate = true;
    }


    function main() {
        container = document.getElementById('wrap')
        scene = new THREE.Scene()
        camera = new THREE.PerspectiveCamera(
            45, 600 / 600, 0.1, 10000
        )
        camera.position.set(100, 300, 100)
        camera.lookAt(new THREE.Vector3(0, 0, 0))
        renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
        })
        renderer.setClearColor(new THREE.Color(0x000000))
        renderer.setSize(600, 600)
        container.appendChild(renderer.domElement)
        orbitControls = new THREE.OrbitControls(camera, renderer.domElement)
        plane()
    }

    function plane() {
        var planeGeo = new THREE.PlaneGeometry(100, 100, 10, 10) //创建平面
        planeMesh = new THREE.Mesh(planeGeo, pureMaterial)
        planeMesh.position.set(0, 0, 0)
        planeMesh.rotation.x = -0.5 * Math.PI
        scene.add(planeMesh)
    }

    function render() {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
    }
</script>

</html>